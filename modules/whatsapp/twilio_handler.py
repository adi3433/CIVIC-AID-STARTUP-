# AUTOGENERATED BY CLAUDE: date=2026-02-05
"""
Twilio WhatsApp Webhook Handler
Owner: Adithyan

This module handles incoming WhatsApp messages via Twilio webhooks
and routes them to the appropriate bot flow.
"""

import os
import json
import requests
from typing import Dict, Any, Optional, Tuple
from flask import Response


# Twilio configuration
TWILIO_ACCOUNT_SID = os.getenv('TWILIO_ACCOUNT_SID', '')
TWILIO_AUTH_TOKEN = os.getenv('TWILIO_AUTH_TOKEN', '')
TWILIO_WHATSAPP_NUMBER = os.getenv('TWILIO_WHATSAPP_NUMBER', 'whatsapp:+14155238886')

# Fireworks AI for responses
FIREWORKS_API_KEY = os.getenv('FIREWORKS_API_KEY', '')
FIREWORKS_API_URL = "https://api.fireworks.ai/inference/v1/chat/completions"
FIREWORKS_MODEL = "accounts/fireworks/models/llama-v3p3-70b-instruct"

# In-memory conversation state (use Redis in production)
CONVERSATION_STATES = {}


class TwilioWebhookHandler:
    """Handle incoming Twilio WhatsApp webhooks."""
    
    def __init__(self, active_bots: Dict[str, Any]):
        """
        Initialize handler with active bot configurations.
        
        Args:
            active_bots: Dict of bot_id -> bot_config
        """
        self.active_bots = active_bots
        self.default_bot = self._get_default_bot()
    
    def _get_default_bot(self) -> Optional[Dict]:
        """Get the first active bot as default."""
        if self.active_bots:
            return list(self.active_bots.values())[0]
        return None
    
    def handle_message(self, data: Dict[str, Any]) -> Response:
        """
        Handle incoming WhatsApp message from Twilio.
        
        Args:
            data: Twilio webhook payload
        
        Returns:
            TwiML response
        """
        # Extract message details
        from_number = data.get('From', '')
        to_number = data.get('To', '')
        message_body = data.get('Body', '').strip()
        message_sid = data.get('MessageSid', '')
        
        print(f"[Twilio] Message from {from_number}: {message_body}")
        
        # Get or create conversation state
        state = self._get_conversation_state(from_number)
        
        # Determine which bot to use
        bot_config = state.get('active_bot') or self.default_bot
        
        if not bot_config:
            response_text = "Sorry, no bot is currently configured. Please try again later."
        else:
            # Process message and get response
            response_text, new_state = self._process_message(
                message_body, 
                bot_config, 
                state
            )
            
            # Update conversation state
            self._update_conversation_state(from_number, new_state)
        
        # Return TwiML response
        return self._create_twiml_response(response_text)
    
    def _get_conversation_state(self, phone_number: str) -> Dict[str, Any]:
        """Get conversation state for a phone number."""
        if phone_number not in CONVERSATION_STATES:
            CONVERSATION_STATES[phone_number] = {
                "phone_number": phone_number,
                "current_step": None,
                "collected_data": {},
                "message_count": 0,
                "active_bot": None,
                "history": []
            }
        return CONVERSATION_STATES[phone_number]
    
    def _update_conversation_state(self, phone_number: str, state: Dict[str, Any]):
        """Update conversation state for a phone number."""
        state['message_count'] = state.get('message_count', 0) + 1
        CONVERSATION_STATES[phone_number] = state
    
    def _process_message(
        self, 
        message: str, 
        bot_config: Dict[str, Any],
        state: Dict[str, Any]
    ) -> Tuple[str, Dict]:
        """
        Process message and determine response based on bot flow.
        
        Args:
            message: User's message
            bot_config: Bot configuration
            state: Current conversation state
        
        Returns:
            Tuple of (response_text, updated_state)
        """
        modules = bot_config.get('modules', {})
        flow = bot_config.get('flow', [])
        current_step = state.get('current_step')
        collected_data = state.get('collected_data', {})
        
        # Add message to history
        state['history'].append({"role": "user", "content": message})
        
        # If no current step, start from beginning
        if not current_step:
            current_step = flow[0] if flow else None
        
        # Process based on current step
        response = ""
        next_step = None
        
        # Find current step index
        step_index = flow.index(current_step) if current_step in flow else 0
        
        # Handle current step
        if current_step and current_step in modules:
            module = modules[current_step]
            config = module.get('config', {})
            category = module.get('category', '')
            
            # Data collection modules - store the response
            if category == 'data_collection':
                variable = config.get('variable', current_step)
                collected_data[variable] = message
                
                # Move to next step
                step_index += 1
                if step_index < len(flow):
                    next_step = flow[step_index]
            
            # Check for intent/keyword routing
            elif current_step == 'intent_detection' or current_step == 'keyword_routing':
                route = self._detect_intent(message, config)
                if route:
                    # Route to specific flow
                    next_step = route
                else:
                    step_index += 1
                    if step_index < len(flow):
                        next_step = flow[step_index]
            
            else:
                # Move to next step
                step_index += 1
                if step_index < len(flow):
                    next_step = flow[step_index]
        else:
            # Default: try to use AI for response
            if self._has_ai_module(modules):
                response = self._get_ai_response(message, bot_config, state)
                state['current_step'] = current_step
                state['collected_data'] = collected_data
                state['history'].append({"role": "assistant", "content": response})
                return response, state
            else:
                next_step = flow[0] if flow else None
        
        # Generate response for next step
        if next_step and next_step in modules:
            next_module = modules[next_step]
            next_config = next_module.get('config', {})
            
            if next_module.get('category') == 'greeting':
                response = next_config.get('message', 'Hello! How can I help you?')
            elif next_module.get('category') == 'data_collection':
                response = next_config.get('prompt', 'Please provide information')
                
                # Format options if it's a selection
                if next_step == 'product_selection':
                    items = next_config.get('items', [])
                    if items:
                        response += "\n\n"
                        for i, item in enumerate(items):
                            response += f"{i+1}. {item.get('label', item.get('id'))}\n"
                elif next_step == 'menu_navigation':
                    options = next_config.get('options', [])
                    if options:
                        response = next_config.get('menu_prompt', 'Please select:') + "\n\n"
                        for opt in options:
                            response += f"{opt['number']}. {opt['label']}\n"
            elif next_module.get('category') == 'actions':
                if next_step == 'booking_appointment':
                    response = next_config.get('prompt_date', 'When would you like to book?')
                elif next_step == 'complaint_registration':
                    response = "Please describe your issue in detail."
                else:
                    response = "Processing your request..."
            else:
                response = "How can I help you further?"
        else:
            # End of flow
            response = self._generate_completion_message(bot_config, collected_data)
        
        # Update state
        state['current_step'] = next_step
        state['collected_data'] = collected_data
        state['history'].append({"role": "assistant", "content": response})
        
        return response, state
    
    def _detect_intent(self, message: str, config: Dict) -> Optional[str]:
        """Detect user intent from message."""
        message_lower = message.lower()
        
        intents = config.get('intents', [])
        for intent in intents:
            keywords = intent.get('keywords', [])
            for keyword in keywords:
                if keyword.lower() in message_lower:
                    return intent.get('route_to')
        
        return None
    
    def _has_ai_module(self, modules: Dict) -> bool:
        """Check if AI chat module is enabled."""
        return 'ai_chat' in modules and modules['ai_chat'].get('enabled', False)
    
    def _get_ai_response(
        self, 
        message: str, 
        bot_config: Dict,
        state: Dict
    ) -> str:
        """Get AI-generated response using Fireworks."""
        if not FIREWORKS_API_KEY:
            return "I'm here to help. Please tell me more about what you need."
        
        # Build system prompt
        business_name = bot_config.get('business_name', 'CivicAid')
        modules = bot_config.get('modules', {})
        
        ai_config = modules.get('ai_chat', {}).get('config', {})
        system_prompt = ai_config.get(
            'system_prompt', 
            f"You are a helpful WhatsApp assistant for {business_name}. Be concise and helpful."
        ).replace('{business_name}', business_name)
        
        # Build conversation history
        messages = [{"role": "system", "content": system_prompt}]
        
        # Add last 5 messages from history
        history = state.get('history', [])[-10:]
        messages.extend(history)
        
        try:
            response = requests.post(
                FIREWORKS_API_URL,
                headers={
                    "Authorization": f"Bearer {FIREWORKS_API_KEY}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": FIREWORKS_MODEL,
                    "messages": messages,
                    "max_tokens": 500,
                    "temperature": 0.7
                },
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                return result.get("choices", [{}])[0].get("message", {}).get("content", "")
            else:
                return "I apologize, I'm having trouble responding right now. Please try again."
        
        except Exception as e:
            print(f"[AI] Error: {e}")
            return "I'm here to help. Could you please rephrase your question?"
    
    def _generate_completion_message(self, bot_config: Dict, collected_data: Dict) -> str:
        """Generate a completion message summarizing collected data."""
        business_name = bot_config.get('business_name', 'Our team')
        
        message = f"Thank you for contacting {business_name}!\n\n"
        
        if collected_data:
            message += "Here's what we have:\n"
            for key, value in collected_data.items():
                formatted_key = key.replace('_', ' ').title()
                message += f"â€¢ {formatted_key}: {value}\n"
        
        message += "\nWe'll get back to you shortly!"
        
        return message
    
    def _create_twiml_response(self, message: str) -> Response:
        """Create a TwiML response for Twilio."""
        twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Message>{message}</Message>
</Response>"""
        
        return Response(twiml, mimetype='text/xml')


def send_whatsapp_message(to: str, message: str) -> Dict[str, Any]:
    """
    Send a WhatsApp message via Twilio.
    
    Args:
        to: Recipient phone number (whatsapp:+1234567890)
        message: Message text
    
    Returns:
        Twilio API response
    """
    if not TWILIO_ACCOUNT_SID or not TWILIO_AUTH_TOKEN:
        return {"error": "Twilio credentials not configured"}
    
    url = f"https://api.twilio.com/2010-04-01/Accounts/{TWILIO_ACCOUNT_SID}/Messages.json"
    
    data = {
        "From": TWILIO_WHATSAPP_NUMBER,
        "To": to if to.startswith('whatsapp:') else f"whatsapp:{to}",
        "Body": message
    }
    
    try:
        response = requests.post(
            url,
            data=data,
            auth=(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
        )
        return response.json()
    except Exception as e:
        return {"error": str(e)}


def reset_conversation(phone_number: str):
    """Reset conversation state for a phone number."""
    if phone_number in CONVERSATION_STATES:
        del CONVERSATION_STATES[phone_number]


if __name__ == "__main__":
    # Demo
    print("Twilio WhatsApp Handler - Testing")
    print("=" * 50)
    
    # Create mock bot config
    mock_bot = {
        "bot_id": "test_bot",
        "business_name": "Test Business",
        "modules": {
            "welcome_message": {
                "enabled": True,
                "category": "greeting",
                "config": {"message": "Hello! Welcome to Test Business!"}
            },
            "collect_name": {
                "enabled": True,
                "category": "data_collection",
                "config": {"prompt": "What's your name?", "variable": "customer_name"}
            }
        },
        "flow": ["welcome_message", "collect_name"]
    }
    
    handler = TwilioWebhookHandler({"test_bot": mock_bot})
    
    # Test message handling
    test_data = {
        "From": "whatsapp:+919876543210",
        "To": "whatsapp:+14155238886",
        "Body": "Hello",
        "MessageSid": "SM123"
    }
    
    print(f"Input: {test_data['Body']}")
    response = handler.handle_message(test_data)
    print(f"Response: {response.data.decode()}")
