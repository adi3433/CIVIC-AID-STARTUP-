# AUTOGENERATED BY CLAUDE: date=2026-02-05
"""
Dispatch Module - Stub Implementation
Owner: Lestlin
Port: 5002

This module handles call dispatch with Twilio-style webhook integration
and failover simulation. Also serves the Next.js dispatch UI.

TODO: Production Integration
1. Integrate with Twilio Voice API
2. Implement real AI classification for call routing
3. Add call recording and transcription
4. Implement agent availability tracking
5. Set up monitoring and alerting

API Endpoints:
- GET /              - Dispatch UI (Next.js)
- POST /dispatch/webhook - Handle call dispatch
- GET /health - Health check
"""

import os
from flask import Flask, request, jsonify, send_from_directory, send_file

# Get the directory where this script is located
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
# Path to Next.js static export
STATIC_DIR = os.path.join(SCRIPT_DIR, 'dispatch-service', 'out')

app = Flask(__name__, static_folder=STATIC_DIR)


# Deterministic responses for demos
DEMO_FALLBACK_RESPONSES = {
    "default": {
        "action": "fallback_ai",
        "classification": "police",
        "transcript": "User: I am being robbed",
        "forward_to": "101"
    },
    "medical": {
        "action": "fallback_ai",
        "classification": "medical",
        "transcript": "User: Someone is having a heart attack",
        "forward_to": "102"
    },
    "fire": {
        "action": "fallback_ai",
        "classification": "fire",
        "transcript": "User: There is a fire in my building",
        "forward_to": "101"
    }
}


@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint."""
    ui_available = os.path.exists(os.path.join(STATIC_DIR, 'index.html'))
    return jsonify({
        "status": "healthy", 
        "module": "dispatch", 
        "port": 5002,
        "ui_available": ui_available
    })


@app.route('/dispatch/webhook', methods=['POST'])
def dispatch_webhook():
    """
    Handle incoming call dispatch webhook.
    
    Request JSON:
    {
        "call_id": "call_12345",
        "from": "+919876543210",
        "primary_busy": true,
        "metadata": {"region": "kerala", "priority": "high"}
    }
    
    Response (if primary_busy=true):
    {
        "action": "fallback_ai",
        "classification": "police",
        "transcript": "User: I am being robbed",
        "forward_to": "101"
    }
    
    Response (if primary_busy=false):
    {
        "action": "connect_primary"
    }
    """
    data = request.get_json()
    
    # Validate required fields
    if not data:
        return jsonify({
            "error": "bad_request",
            "message": "Request body must be JSON"
        }), 400
    
    call_id = data.get('call_id')
    caller_from = data.get('from')
    primary_busy = data.get('primary_busy', False)
    
    if not call_id:
        return jsonify({
            "error": "missing_field",
            "message": "call_id is required"
        }), 400
    
    if not caller_from:
        return jsonify({
            "error": "missing_field",
            "message": "from is required"
        }), 400
    
    # Dispatch logic
    if not primary_busy:
        return jsonify({
            "action": "connect_primary",
            "call_id": call_id,
            "note": "STUB: Would connect to primary agent via Twilio"
        })
    
    # Fallback to AI - deterministic response for demos
    metadata = data.get('metadata', {})
    emergency_type = metadata.get('emergency_type', 'default')
    
    response = DEMO_FALLBACK_RESPONSES.get(
        emergency_type, 
        DEMO_FALLBACK_RESPONSES['default']
    ).copy()
    
    response['call_id'] = call_id
    response['note'] = "STUB: Replace with actual Twilio + AI integration"
    
    # TODO: In production:
    # 1. Transcribe the call using speech-to-text
    # 2. Classify the emergency using LLM
    # 3. Route to appropriate service
    # 4. Log call details for tracking
    
    return jsonify(response)


# ============================================
# Static File Serving for Next.js UI
# ============================================

@app.route('/')
def serve_index():
    """Serve the main dispatch UI."""
    index_path = os.path.join(STATIC_DIR, 'index.html')
    if os.path.exists(index_path):
        return send_file(index_path)
    else:
        return jsonify({
            "error": "ui_not_built",
            "message": "Next.js UI not built. Run: cd dispatch-service && npm run build",
            "api_available": True,
            "endpoints": ["/dispatch/webhook", "/health"]
        }), 404


@app.route('/<path:path>')
def serve_static(path):
    """Serve static files from Next.js build."""
    # Check if the file exists directly
    file_path = os.path.join(STATIC_DIR, path)
    
    if os.path.exists(file_path) and os.path.isfile(file_path):
        return send_from_directory(STATIC_DIR, path)
    
    # For SPA routing, try to serve index.html from subdirectory
    if os.path.isdir(file_path):
        index_path = os.path.join(file_path, 'index.html')
        if os.path.exists(index_path):
            return send_file(index_path)
    
    # Try adding .html extension
    html_path = file_path + '.html'
    if os.path.exists(html_path):
        return send_file(html_path)
    
    # Try index.html in path directory
    path_index = os.path.join(STATIC_DIR, path, 'index.html')
    if os.path.exists(path_index):
        return send_file(path_index)
    
    # Fallback to main index for client-side routing
    main_index = os.path.join(STATIC_DIR, 'index.html')
    if os.path.exists(main_index):
        return send_file(main_index)
    
    return jsonify({"error": "not_found", "path": path}), 404


# CLI mode for testing
if __name__ == '__main__':
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == '--cli':
        # CLI demo mode
        print("=" * 50)
        print("Dispatch Module - CLI Demo")
        print("=" * 50)
        
        import json
        
        # Simulate primary busy scenario
        test_request = {
            "call_id": "call_demo_001",
            "from": "+919876543210",
            "primary_busy": True,
            "metadata": {"region": "kerala"}
        }
        
        print("\nTest Request:")
        print(json.dumps(test_request, indent=2))
        
        print("\nExpected Response (primary_busy=True):")
        response = DEMO_FALLBACK_RESPONSES['default'].copy()
        response['call_id'] = test_request['call_id']
        print(json.dumps(response, indent=2))
        
        print("\nExpected Response (primary_busy=False):")
        print(json.dumps({"action": "connect_primary", "call_id": test_request['call_id']}, indent=2))
    else:
        # Server mode
        ui_available = os.path.exists(os.path.join(STATIC_DIR, 'index.html'))
        
        print("=" * 50)
        print("Dispatch Module - Starting on port 5002")
        print("=" * 50)
        print("\nAvailable endpoints:")
        print("  GET  /                 - Dispatch UI" + (" ✓" if ui_available else " (not built)"))
        print("  POST /dispatch/webhook - Handle call dispatch")
        print("  GET  /health           - Health check")
        
        if not ui_available:
            print("\n⚠️  UI not built. To build:")
            print("  cd dispatch-service && npm install && npm run build")
        
        print("\nDemo command:")
        print('  curl -X POST http://localhost:5002/dispatch/webhook \\')
        print('    -H "Content-Type: application/json" \\')
        print('    -d \'{"call_id": "demo_001", "from": "+919876543210", "primary_busy": true}\'')
        print("=" * 50)
        app.run(host='0.0.0.0', port=5002, debug=True)

