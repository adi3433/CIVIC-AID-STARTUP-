# AUTOGENERATED BY CLAUDE: date=2026-02-05
"""
Dispatch Module - Tests
Owner: Lestlin

Tests for the dispatch webhook endpoint.
All tests use deterministic mock data and require no external network calls.
"""

import json
import pytest
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from dispatcher_stub import app


@pytest.fixture
def client():
    """Create test client."""
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client


class TestHealthEndpoint:
    """Tests for /health endpoint."""
    
    def test_health_returns_ok(self, client):
        """Health check should return healthy status."""
        response = client.get('/health')
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['status'] == 'healthy'
        assert data['module'] == 'dispatch'
        assert data['port'] == 5002


class TestDispatchWebhook:
    """Tests for /dispatch/webhook endpoint."""
    
    def test_primary_not_busy_connects(self, client):
        """Should return connect_primary when primary is not busy."""
        response = client.post(
            '/dispatch/webhook',
            json={
                'call_id': 'call_test_001',
                'from': '+919876543210',
                'primary_busy': False
            },
            content_type='application/json'
        )
        
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['action'] == 'connect_primary'
        assert data['call_id'] == 'call_test_001'
    
    def test_primary_busy_fallback(self, client):
        """Should return fallback_ai when primary is busy."""
        response = client.post(
            '/dispatch/webhook',
            json={
                'call_id': 'call_test_002',
                'from': '+919876543210',
                'primary_busy': True,
                'metadata': {'region': 'kerala'}
            },
            content_type='application/json'
        )
        
        assert response.status_code == 200
        data = json.loads(response.data)
        
        # Verify fallback response structure
        assert data['action'] == 'fallback_ai'
        assert 'classification' in data
        assert 'transcript' in data
        assert 'forward_to' in data
        assert data['call_id'] == 'call_test_002'
    
    def test_missing_call_id(self, client):
        """Should return 400 when call_id is missing."""
        response = client.post(
            '/dispatch/webhook',
            json={
                'from': '+919876543210',
                'primary_busy': True
            },
            content_type='application/json'
        )
        
        assert response.status_code == 400
        data = json.loads(response.data)
        assert data['error'] == 'missing_field'
    
    def test_missing_from(self, client):
        """Should return 400 when from is missing."""
        response = client.post(
            '/dispatch/webhook',
            json={
                'call_id': 'call_test_003',
                'primary_busy': True
            },
            content_type='application/json'
        )
        
        assert response.status_code == 400
        data = json.loads(response.data)
        assert data['error'] == 'missing_field'
    
    def test_deterministic_output(self, client):
        """Same input should produce same output."""
        request_data = {
            'call_id': 'call_test_004',
            'from': '+919876543210',
            'primary_busy': True
        }
        
        response1 = client.post(
            '/dispatch/webhook',
            json=request_data,
            content_type='application/json'
        )
        response2 = client.post(
            '/dispatch/webhook',
            json=request_data,
            content_type='application/json'
        )
        
        data1 = json.loads(response1.data)
        data2 = json.loads(response2.data)
        
        assert data1['classification'] == data2['classification']
        assert data1['transcript'] == data2['transcript']


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
